---
title: Converting a Rust Crate to Wasm
tags: Rust, Wasm
category: Guides
---

Starting from scratch and delving into targeting a wasm build from a *simple* rust crate with only two dependencies: `sha2` and `rand`. Seems simple? Perhaps. Warts and all with the failures so I remember for next time.  

<!--more-->
## Requirements

* [wasm-pack](https://rustwasm.github.io/wasm-pack/installer/)

* [npm](https://www.npmjs.com/get-npm)


## Getting Started

Additions to Cargo.toml
```toml
[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = { version = "0.2", optional = true}

[features]
wasm = ["wasm-bindgen"]

[profile.release]
# Tell `rustc` to optimize for small code size.
opt-level = "s"
```

Inside the project directory:
```bash
wasm-pack build
```

This produces artifacts inside a new directory `pkg`:

* The .wasm file is the WebAssembly binary that is generated by the Rust compiler from our Rust sources. It contains the compiled-to-wasm versions of all of our Rust functions and data. 

* The .js file is generated by wasm-bindgen and contains JavaScript glue for importing DOM and JavaScript functions into Rust and exposing a nice API to the WebAssembly functions to JavaScript. Right now, this glue isn't doing much, but when we start passing more interesting values back and forth between wasm and JavaScript, it will help shepherd those values across the boundary.

* The .d.ts file contains TypeScript type declarations for the JavaScript glue. If you are using TypeScript, you can have your calls into WebAssembly functions type checked, and your IDE can provide autocompletions and suggestions! If you aren't using TypeScript, you can safely ignore this file.

* The package.json file contains metadata about the generated JavaScript and WebAssembly package. This is used by npm and JavaScript bundlers to determine dependencies across packages, package names, versions, and a bunch of other stuff. It helps us integrate with JavaScript tooling and allows us to publish our package to npm.

To build a web page template run in the project directory:
```bash
npm init wasm-app www
```

Inside the new `www` folder:

* package.json comes pre-configured with webpack and webpack-dev-server dependencies, as well as a dependency on hello-wasm-pack, which is a version of the initial wasm-pack-template package that has been published to npm.

* webpack.config.js configures webpack and its local development server. It comes pre-configured, and you shouldn't have to tweak this at all to get webpack and its local development server working.

* index.html is the root HTML file for the Web page. It doesn't do much other than load bootstrap.js, which is a very thin wrapper around index.js.

* index.js is the main entry point for our Web page's JavaScript. It imports the hello-wasm-pack npm package, which contains the default wasm-pack-template's compiled WebAssembly and JavaScript glue, then it calls hello-wasm-pack's greet function.

Rather than use the hello-wasm-pack package from npm, we want to use our project instead.

Modify `<project>/www/package.json` to include:
```json
"dependencies": {
    "<project>": "file:../pkg"
}
```

Replace all lines in `<project>/www/index.js` with:
```js
import * as wasm from "<project>"
```
In the `www` directory install all the depenencies:
```bash 
npm install
```

#### Running a local development server

In the `www` directory:
```bash
npm run start
```

Navigate to http://localhost:8080/

It should be healthily blank and returning a 200 status.


#### Wasm-Pack Build Error

Along the way I ended up with a frustrating build error for a wasm-dependency. 
```bash
error: Could not compile `wasm-bindgen-macro-support`. 
```
Struggling through semi-related wasm build issues on github I found someone who solved it by simply deleting Cargo.lock and surprisingly it worked a treat.

## Adding functionality

This example will be using a KEM implementation I wrote with 3 public functions available: 
* `generate_key()`
* `encapsulate(public_key)`
* `decapsulate(cipher_text, private_key)`.  


#### Adding a button to generate a keypair.

Modify `www/index.html`:
```html
  <body>
    <button id="generate-key">Generate Keys</button>
    <p id="publicKey"></p>
    <p id="privateKey"></p>
    <script src="./bootstrap.js"></script>
  </body>
```

Add an event listener in `www/index.js`:
```js
const generateKeyButton = document.getElementById("generate-key");

generateKeyButton.addEventListener("click", event => {
    const [public_key, private_key] = wasm.generate_key();
    document.getElementById("publicKey").innerHTML = public_key;
    document.getElementById("privateKey").innerHTML = private_key;
});
```

Add the wasm_bindgen attribute to `src/lib.rs` in order for rust functions to cross the wasm ABI:
```rust
extern crate wasm_bindgen;
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn generate_key()->([u8; PK_SIZE], [u8; SK_SIZE]){
/// trimmed
```

Build: 
```bash
wasm-pack build
```

Oh:
```bash
error[E0277]: the trait bound `([u8; 1218], [u8; 1600]): wasm_bindgen::convert::IntoWasmAbi` is not satisfied
```

So what types are in bounds and can be exported?  

|                        	| T parameter 	| &T parameter 	| &mut T parameter 	| T return value 	| Option<T> parameter 	| Option<T> 	| JavaScript                                                                                                                	|
|------------------------	|-------------	|--------------	|------------------	|----------------	|---------------------	|-----------	|---------------------------------------------------------------------------------------------------------------------------	|
| Struct types           	| Yes         	| Yes          	| Yes              	| Yes            	| No                  	| No        	| Instances of a wasm-bindgen-generated JavaScript class Whatever { ... }                                                   	|
| *const T and *mut T    	| Yes         	| No           	| No               	| Yes            	| No                  	| No        	| A JavaScript number value                                                                                                 	|
| Numbers (u8, i16, f32, etc.) 	| Yes         	| No           	| No               	| Yes            	| Yes                 	| Yes       	| A JavaScript number value                                                                                                 	|
| bool                   	| Yes         	| No           	| No               	| Yes            	| Yes                 	| Yes       	| A JavaScript boolean value                                                                                                	|
| char                   	| Yes         	| No           	| No               	| Yes            	| No                  	| No        	| A JavaScript string value                                                                                                 	|
| str                    	| No          	| Yes          	| No               	| No             	| No                  	| No        	| JavaScript string value                                                                                                   	|
| String                 	| Yes         	| No           	| No               	| Yes            	| Yes                 	| Yes       	| JavaScript string value                                                                                                   	|
| Number Slices          	| No          	| Yes          	| Yes              	| No             	| No                  	| No        	| A JavaScript TypedArray view of the Wasm memory for the boxed slice of the appropriate type (Int32Array, Uint8Array, etc) 	|
| Boxed Number Slices    	| Yes         	| No           	| No               	| Yes            	| Yes                 	| Yes       	| A JavaScript TypedArray of the appropriate type (Int32Array, Uint8Array, etc...)                                          	|
| Result<T, JsValue>     	| No          	| No           	| No               	| No             	| No                  	| Yes       	| Same as T, or an exception                                                                                                	|
|                        	|             	|              	|                  	|                	|                     	|           	|                                                                                                                           	|

Whew. The finer details along with imports and using JsValue types can be found [here](https://rustwasm.github.io/docs/wasm-bindgen/reference/types.html)

While it says number slice*s* you can only return one. Boxing up the tuple from the somewhat inaccurately named generate_key() function also won't work. So a struct it is.

To avoid breaking the API I'll make a new function for now that returns a Keys struct.

```rust
#[wasm_bindgen]
pub struct Keys{
    public: Box<[u8]>,
    private: Box<[u8]>
}

#[wasm_bindgen]
pub fn generate_key_wasm()-> Keys{
/// trimmed
```

And... it builds!

Going back to `www/index.js`:
```js
generateKeyButton.addEventListener("click", event => {
    let keys = wasm.generate_key_wasm();
    const pubkey = keys.public();
    const privkey = keys.private();
    
    document.getElementById("publicKey").innerHTML = toHexString(pubkey);
    document.getElementById("privateKey").innerHTML = toHexString(privkey); 
});
```

Should be all good now right? Wrong.

In the console when the click event is triggered:

```bash
"RuntimeError: unreachable executed"
```
Highly informative error message, how wonderful.

## Debugging

`set_panic_hook()` will push panic messages from rust into the browser console.

In `Cargo.toml`:
```toml

[dependencies]
# The `console_error_panic_hook` crate provides better debugging of panics by
# logging them with `console.error`. This is great for development, but requires
# all the `std::fmt` and `std::panicking` infrastructure, so isn't great for
# code size when deploying.
console_error_panic_hook = { version = "0.1.1", optional = true }

[features]
default = ["console_error_panic_hook"]
```

In `lib.rs`:
```rs
#[wasm_bindgen]
pub fn generate_key_wasm()-> Keys{
    set_panic_hook();
/// Trimmed


pub fn set_panic_hook() {
    // When the `console_error_panic_hook` feature is enabled, we can call the
    // `set_panic_hook` function at least once during initialization, and then
    // we will get better error messages if our code ever panics.
    //
    // For more details see
    // https://github.com/rustwasm/console_error_panic_hook#readme
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();
}
```

The new error message in the browser console:

```bash
panicked at 'could not initialize thread_rng: All entropy sources failed (permanently unavailable); cause: OsRng: support for wasm32 requires emscripten, stdweb or wasm-bindgen (permanently unavailable)', /home/mtchll/.cargo/registry/src/github.com-1ecc6299db9ec823/rand-0.6.5/src/rngs/thread.rs:80:17
```

Tremendous. 

Despite only two crates and wasm_bindgen as dependencies, it still needs some work. Rand since 0.6 has now got wasm support as a feature. In `Cargo.toml`:
```toml
[dependencies]
rand = {version = "0.6.5", features =["wasm-bindgen"]}
```

Build again with `wasm-pack build`.

We have action! In the form of two undefined variables appearing on a click event.

## Logging 
In `Cargo.toml`:
```toml
[dependencies]
web-sys = {version = "0.3.22", features = ["console"]}
```

In `lib.rs`:
```rust
extern crate web_sys;
use web_sys::console;

/// Trimmed
console::log_2(&public, &private);
Keys(public, private)
```

And the error:
```
expected struct `wasm_bindgen::JsValue`, found array of 1218 elements
```
More on JsValue [here](https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html)

The problem: Struct variables aren't public. But the `Box<[u8]>` type doesn't implement `copy`. It needs to be an explicit clone.

`Cargo.toml`:
```rust
#[wasm_bindgen]
impl Keys {
    pub fn public(&self) -> Box<[u8]> {
        self.public.clone()
    }

    pub fn private(&self) -> Box<[u8]> {
        self.private.clone()
    }
}
```

Format the byte array as a hex string in `www/index.js`:
```js
function toHexString(byteArray) {
  return byteArray.reduce((output, elem) => 
    (output + ('0' + elem.toString(16)).slice(-2)),
    '');
}
```
It's alive! Now the other two.

The original encapsulate function looks likes this:
```rust
pub fn encapsulate(pk : [u8; PK_SIZE])-> ([u8; CT_SIZE], [u8; K_SIZE]){
    let mut r = [0i8; P];
    let mut rng = rand::thread_rng();
    zx::random::random_tsmall(&mut r, &mut rng);   
    create_cipher(r, pk)
}
```

Wasm-bindgen won't accept those array types so they need to be boxed, along with a struct and a function to convert the box into an array. 
```rust
#[wasm_bindgen]
pub struct Encapsulated {
    cipher_text: Box<[u8]>,
    shared_key: Box<[u8]>
}

#[wasm_bindgen]
pub fn encapsulate_wasm(pk : Box<[u8]>)-> Encapsulated {
    let mut r = [0i8; P];
    let mut rng = rand::thread_rng();
    zx::random::random_tsmall(&mut r, &mut rng);   
    let (cipher, shared) = create_cipher(r, pk_box_to_array(pk));
    Encapsulated {
        cipher_text: Box::new(cipher),
        shared_key: Box::new(shared)
    }
}

fn pk_box_to_array(pk: Box<[u8]>) -> [u8; PK_SIZE] {
    let mut arr =[0u8; PK_SIZE];
    arr.copy_from_slice(&pk);
    arr
}
```

The original decapsulate function:
```rust
pub fn decapsulate(cstr: [u8; CT_SIZE], sk: [u8; SK_SIZE])-> Result<[u8; K_SIZE], ()> {
  /// Trimmed
  if check { Ok(k) } else { Err(()) }
}
```

This will need to be converted to:
```rust
#[wasm_bindgen]
pub fn decapsulate_wasm(cstr: Box<[u8]>, sk: Box<[u8]>)-> Result<Box<[u8]>, JsValue> {
  /// Trimmed
  if check { Ok(Box::new(k)) } else { Err(JsValue::null()) }
}
```

The Uint8Array javascript types will be passed through the ABI and converted into `Box<[u8]>` types.

`index.html` additions:
```html
    <button id="encapsulate">Encapsulate with Public Key</button>
    <br><br>
    Cipher Text: 
    <p id="cipherText"></p>
    Shared Key: 
    <p id="sharedKey"></p>
    <br>
    <button id="decapsulate">Decapsulate with Ciphertext and Secret Key</button>
    <br><br>
    Shared Key: 
    <p id="sharedKeyDecap"></p>
```


Fixing up `index.js`:
```js
const encapButton = document.getElementById("encapsulate");
const decapButton = document.getElementById("decapsulate");

var pubkey;
var privkey;
var cipher;

encapButton.addEventListener("click", event => {
    let encapsulated = wasm.encapsulate_wasm(pubkey);
    cipher = encapsulated.cipher_text();
    let shared = encapsulated.shared_key();
    
    document.getElementById("cipherText").innerHTML = toHexString(cipher);
    document.getElementById("sharedKey").innerHTML = toHexString(shared);
});
    
decapButton.addEventListener("click", event => {
    let decapsulated = wasm.decapsulate_wasm(cipher, privkey);
    
    document.getElementById("sharedKeyDecap").innerHTML = toHexString(decapsulated);
});
```

And there it is. A Wasm implementation of the Streamlined NTRU Prime 4591<sup>761</sup> algorithm ready to be used in the browser. This was only intended as a naive starting from scratch walkthrough with all the messy bits included of learning-to-wasm, a lot more cleaning up and adding conditional compilation is needed before merging the wasm branch created here. 

## Binary Size

With logging and panic hooks still included the `streamlined_ntru_prime_bg.wasm` comes out at 110 KB. Removing those gets it down to 92 KB, the release profile has the LLVM opt-level of "s" to optimise for small size. Changing that to "z" yields 95 KB despite which can happen despite being the ultra-small option. 

Adding `lto = true` to the profile.release section in `Cargo.toml` will add link time optimisations. 

